/*
 * Copyright 2020 The Backstage Authors
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

import fs from 'fs-extra';
import mockFs from 'mock-fs';
import { ExtendedPackage } from '../monorepo';
import { Lockfile } from './Lockfile';

const HEADER = `# THIS IS AN AUTOGENERATED FILE. DO NOT EDIT THIS FILE DIRECTLY.
# yarn lockfile v1

`;

const mockA = `${HEADER}
a@^1:
  version "1.0.1"
  resolved "https://my-registry/a-1.0.01.tgz#abc123"
  integrity sha512-xyz
  dependencies:
    b "^2"

b@2.0.x:
  version "2.0.1"

b@^2:
  version "2.0.0"
`;

const mockADedup = `${HEADER}
a@^1:
  version "1.0.1"
  resolved "https://my-registry/a-1.0.01.tgz#abc123"
  integrity sha512-xyz
  dependencies:
    b "^2"

b@2.0.x, b@^2:
  version "2.0.1"
`;

const mockB = `${HEADER}
"@s/a@*", "@s/a@1 || 2", "@s/a@^1":
  version "1.0.1"

"@s/a@^2.0.x":
  version "2.0.0"
`;

const mockBDedup = `${HEADER}
"@s/a@*", "@s/a@1 || 2", "@s/a@^2.0.x":
  version "2.0.0"

"@s/a@^1":
  version "1.0.1"
`;

describe('Lockfile', () => {
  afterEach(() => {
    mockFs.restore();
  });

  it('should load and serialize mockA', async () => {
    mockFs({
      '/yarn.lock': mockA,
    });

    const lockfile = await Lockfile.load('/yarn.lock');
    expect(lockfile.get('a')).toEqual([
      { range: '^1', version: '1.0.1', dataKey: 'a@^1' },
    ]);
    expect(lockfile.get('b')).toEqual([
      { range: '2.0.x', version: '2.0.1', dataKey: 'b@2.0.x' },
      { range: '^2', version: '2.0.0', dataKey: 'b@^2' },
    ]);
    expect(lockfile.toString()).toBe(mockA);
  });

  it('should deduplicate and save mockA', async () => {
    mockFs({
      '/yarn.lock': mockA,
    });

    const lockfile = await Lockfile.load('/yarn.lock');
    const result = lockfile.analyze({ localPackages: new Map() });
    expect(result).toEqual({
      invalidRanges: [],
      newRanges: [],
      newVersions: [
        {
          name: 'b',
          range: '^2',
          oldVersion: '2.0.0',
          newVersion: '2.0.1',
        },
      ],
    });

    expect(lockfile.toString()).toBe(mockA);
    lockfile.replaceVersions(result.newVersions);
    expect(lockfile.toString()).toBe(mockADedup);

    await expect(fs.readFile('/yarn.lock', 'utf8')).resolves.toBe(mockA);
    await expect(lockfile.save('/yarn.lock')).resolves.toBeUndefined();
    await expect(fs.readFile('/yarn.lock', 'utf8')).resolves.toBe(mockADedup);
  });

  it('should deduplicate mockB', async () => {
    mockFs({
      '/yarn.lock': mockB,
    });

    const lockfile = await Lockfile.load('/yarn.lock');
    const result = lockfile.analyze({ localPackages: new Map() });
    expect(result).toEqual({
      invalidRanges: [],
      newRanges: [
        {
          name: '@s/a',
          oldRange: '^1',
          newRange: '^2.0.x',
          oldVersion: '1.0.1',
          newVersion: '2.0.0',
        },
      ],
      newVersions: [
        {
          name: '@s/a',
          range: '*',
          oldVersion: '1.0.1',
          newVersion: '2.0.0',
        },
        {
          name: '@s/a',
          range: '1 || 2',
          oldVersion: '1.0.1',
          newVersion: '2.0.0',
        },
      ],
    });

    expect(lockfile.toString()).toBe(mockB);
    lockfile.replaceVersions(result.newVersions);
    expect(lockfile.toString()).toBe(mockBDedup);
  });
});

const newHeader = `# This file is generated by running "yarn install" inside your project.
# Manual changes might be lost - proceed with caution!

__metadata:
  version: 6
  cacheKey: 8
`;

const mockANew = `${newHeader}
a@^1:
  version: 1.0.1
  dependencies:
    b: ^2
  integrity: sha512-xyz
  resolved: "https://my-registry/a-1.0.01.tgz#abc123"

"b@2.0.x, b@^2.0.1":
  version: 2.0.1

b@^2:
  version: 2.0.0
`;

const mockANewDedup = `${newHeader}
a@^1:
  version: 1.0.1
  dependencies:
    b: ^2
  integrity: sha512-xyz
  resolved: "https://my-registry/a-1.0.01.tgz#abc123"

"b@2.0.x, b@^2.0.1":
  version: 2.0.1

b@^2:
  version: 2.0.1
`;

const mockANewLocal = `${newHeader}
a@^1:
  version: 1.0.1
  dependencies:
    b: ^2
  integrity: sha512-xyz
  resolved: "https://my-registry/a-1.0.01.tgz#abc123"

"b@2.0.x, b@^2.0.1":
  version: 0.0.0-use.local

b@^2:
  version: 2.0.0
`;

const mockANewLocalDedup = `${newHeader}
a@^1:
  version: 1.0.1
  dependencies:
    b: ^2
  integrity: sha512-xyz
  resolved: "https://my-registry/a-1.0.01.tgz#abc123"

"b@2.0.x, b@^2.0.1":
  version: 0.0.0-use.local

b@^2:
  version: 0.0.0-use.local
`;

describe('New Lockfile', () => {
  afterEach(() => {
    mockFs.restore();
  });

  it('should load and serialize mockANew', async () => {
    mockFs({
      '/yarn.lock': mockANew,
    });

    const lockfile = await Lockfile.load('/yarn.lock');
    expect(lockfile.get('a')).toEqual([
      { range: '^1', version: '1.0.1', dataKey: 'a@^1' },
    ]);
    expect(lockfile.get('b')).toEqual([
      { range: '2.0.x', version: '2.0.1', dataKey: 'b@2.0.x, b@^2.0.1' },
      { range: '^2.0.1', version: '2.0.1', dataKey: 'b@2.0.x, b@^2.0.1' },
      { range: '^2', version: '2.0.0', dataKey: 'b@^2' },
    ]);
    expect(lockfile.toString()).toBe(mockANew);
  });

  it('should deduplicate and save mockANew', async () => {
    mockFs({
      '/yarn.lock': mockANew,
    });

    const lockfile = await Lockfile.load('/yarn.lock');
    const result = lockfile.analyze({ localPackages: new Map() });
    expect(result).toEqual({
      invalidRanges: [],
      newRanges: [],
      newVersions: [
        {
          name: 'b',
          range: '^2',
          oldVersion: '2.0.0',
          newVersion: '2.0.1',
        },
      ],
    });

    expect(lockfile.toString()).toBe(mockANew);
    lockfile.replaceVersions(result.newVersions);
    expect(lockfile.toString()).toBe(mockANewDedup);

    await expect(fs.readFile('/yarn.lock', 'utf8')).resolves.toBe(mockANew);
    await expect(lockfile.save('/yarn.lock')).resolves.toBeUndefined();
    await expect(fs.readFile('/yarn.lock', 'utf8')).resolves.toBe(
      mockANewDedup,
    );
  });

  it('should deduplicate and save mockANewLocal', async () => {
    mockFs({
      '/yarn.lock': mockANewLocal,
    });

    const lockfile = await Lockfile.load('/yarn.lock');
    const result = lockfile.analyze({
      localPackages: new Map([
        [
          'b',
          {
            packageJson: { version: '2.0.1' },
          } as ExtendedPackage,
        ],
      ]),
    });
    expect(result).toEqual({
      invalidRanges: [],
      newRanges: [],
      newVersions: [
        {
          name: 'b',
          range: '^2',
          oldVersion: '2.0.0',
          newVersion: '0.0.0-use.local',
        },
      ],
    });

    expect(lockfile.toString()).toBe(mockANewLocal);
    lockfile.replaceVersions(result.newVersions);
    expect(lockfile.toString()).toBe(mockANewLocalDedup);

    await expect(fs.readFile('/yarn.lock', 'utf8')).resolves.toBe(
      mockANewLocal,
    );
    await expect(lockfile.save()).resolves.toBeUndefined();
    await expect(fs.readFile('/yarn.lock', 'utf8')).resolves.toBe(
      mockANewLocalDedup,
    );
  });

  describe('diff', () => {
    const lockfileLegacyA = Lockfile.parse(`${HEADER}
a@^1:
  version "1.0.1"
  resolved "https://my-registry/a-1.0.01.tgz#abc123"
  integrity sha512-xyz
  dependencies:
    b "^2"

b@3:
  version "3.0.1"
  integrity sha512-abc1

b@2.0.x:
  version "2.0.1"
  integrity sha512-abc2

b@^2:
  version "2.0.0"
  integrity sha512-abc3

c@^1:
  version "1.0.1"
  integrity x
`);

    const lockfileLegacyB = Lockfile.parse(`${HEADER}
a@^1:
  version "1.0.1"
  resolved "https://my-registry/a-1.0.01.tgz#abc123"
  integrity sha512-xyz-other
  dependencies:
    b "^2"

b@2.0.x, b@^2:
  version "2.0.0"
  integrity sha512-abc3

b@4:
  version "4.0.0"
  integrity sha512-abc

d@^1:
  version "1.0.1"
  integrity x
`);

    const lockfileModernA = Lockfile.parse(`${HEADER}
"a@^1":
  version "1.0.1"
  resolved "https://my-registry/a-1.0.01.tgz#abc123"
  checksum sha512-xyz
  dependencies:
    b "^2"

"b@3":
  version "3.0.1"
  checksum sha512-abc1

"b@2.0.x":
  version "2.0.1"
  checksum sha512-abc2

"b@^2":
  version "2.0.0"
  checksum sha512-abc3

"c@^1":
  version "1.0.1"
  checksum x
`);

    const lockfileModernB = Lockfile.parse(`${HEADER}
"a@^1":
  version "1.0.1"
  resolution "a@npm:1.0.1"
  checksum sha512-xyz-other
  dependencies:
    b "^2"

"b@2.0.x, b@^2":
  version "2.0.0"
  checksum sha512-abc3

"b@4":
  version "4.0.0"
  checksum sha512-abc

"d@^1":
  version "1.0.1"
  checksum x
`);

    it('should diff two legacy lockfiles', async () => {
      expect(lockfileLegacyA.diff(lockfileLegacyB)).toEqual({
        added: [
          { name: 'b', range: '4' },
          { name: 'd', range: '^1' },
        ],
        changed: [
          { name: 'a', range: '^1' },
          { name: 'b', range: '2.0.x' },
        ],
        removed: [
          { name: 'b', range: '3' },
          { name: 'c', range: '^1' },
        ],
      });
      expect(lockfileLegacyB.diff(lockfileLegacyA)).toEqual({
        added: [
          { name: 'b', range: '3' },
          { name: 'c', range: '^1' },
        ],
        changed: [
          { name: 'a', range: '^1' },
          { name: 'b', range: '2.0.x' },
        ],
        removed: [
          { name: 'b', range: '4' },
          { name: 'd', range: '^1' },
        ],
      });
    });

    it('should diff two modern lockfiles', async () => {
      expect(lockfileModernA.diff(lockfileModernB)).toEqual({
        added: [
          { name: 'b', range: '4' },
          { name: 'd', range: '^1' },
        ],
        changed: [
          { name: 'a', range: '^1' },
          { name: 'b', range: '2.0.x' },
        ],
        removed: [
          { name: 'b', range: '3' },
          { name: 'c', range: '^1' },
        ],
      });
      expect(lockfileModernB.diff(lockfileModernA)).toEqual({
        added: [
          { name: 'b', range: '3' },
          { name: 'c', range: '^1' },
        ],
        changed: [
          { name: 'a', range: '^1' },
          { name: 'b', range: '2.0.x' },
        ],
        removed: [
          { name: 'b', range: '4' },
          { name: 'd', range: '^1' },
        ],
      });
    });

    it('should diff legacy and modern lockfiles', async () => {
      expect(lockfileLegacyA.diff(lockfileModernB)).toEqual({
        added: [
          { name: 'b', range: '4' },
          { name: 'd', range: '^1' },
        ],
        changed: [
          { name: 'a', range: '^1' },
          { name: 'b', range: '2.0.x' },
        ],
        removed: [
          { name: 'b', range: '3' },
          { name: 'c', range: '^1' },
        ],
      });
      expect(lockfileLegacyB.diff(lockfileModernA)).toEqual({
        added: [
          { name: 'b', range: '3' },
          { name: 'c', range: '^1' },
        ],
        changed: [
          { name: 'a', range: '^1' },
          { name: 'b', range: '2.0.x' },
        ],
        removed: [
          { name: 'b', range: '4' },
          { name: 'd', range: '^1' },
        ],
      });
    });

    it('should diff modern and legacy lockfiles', async () => {
      expect(lockfileModernA.diff(lockfileLegacyB)).toEqual({
        added: [
          { name: 'b', range: '4' },
          { name: 'd', range: '^1' },
        ],
        changed: [
          { name: 'a', range: '^1' },
          { name: 'b', range: '2.0.x' },
        ],
        removed: [
          { name: 'b', range: '3' },
          { name: 'c', range: '^1' },
        ],
      });
      expect(lockfileModernB.diff(lockfileLegacyA)).toEqual({
        added: [
          { name: 'b', range: '3' },
          { name: 'c', range: '^1' },
        ],
        changed: [
          { name: 'a', range: '^1' },
          { name: 'b', range: '2.0.x' },
        ],
        removed: [
          { name: 'b', range: '4' },
          { name: 'd', range: '^1' },
        ],
      });
    });
  });
});
